### 1.1 GraphQL 이란?

GraphQL은 API를 만들 때 사용할수 있는 쿼리 언어. 쿼리에 대한 데이터를 받을 수 있는 런타임이기도 함

예시 참고 : [스타워즈 API](https://graphql.org/swapi-graphql/) (GraqhQL로 감싼 REST API - 쿼리문을 보내고 데이터를 받을 수 있음)

GraphQL 쿼리는 실제로 필요한 데이터만 받도록 작성할 수 있음

```graphql
# query
query {
  person(personID: 5){
    name
    birthYear
    created
  }
}

# response
{
  "data": {
    "person": {
      "name": "Leia Organa",
      "birthYear": "19BBY",
      "created": "2014-12-10T15:20:09.791000Z"
    }
  }
}
```

JSON 데이터로 되어있는데, 데이터 형태가 쿼리문과 일치함

쿼리문을 중첩하여 실행하면 연관된 객체를 응답 데이터로 같이 받을 수 있음. HTTP 요청 하나만 가지고 데이터 타입 두 가지에 대한 응답을 얻을 수 있다. 복수의 객체 데이터를 받기위해 요청을 여러번 반복할 필요가 없음

GraphQL 서비스를 만들려면 GraphQL 스키마에서 사용할 타입을 정의해야된다. **미리 정의된 객체**를 바탕으로 만들어진다.

```graphql
# Person 객체
type Person{
	id: ID!
	name: String
	birthYear: String
	...
}
```

Person 타입에는 모든 필드가 각 필드의 타입과 함께 정의되어 있다. 

GraphQL은 선언형(declarative) 데이터 페칭 언어라고 흔히 일컬어짐 

→ '무슨' 데이터가 필요한지에 대한 요구사항만 작성하면 된다. '어떻게'는 신경 쓰지 않아도 됨
<br /><br />


### 1.1.1 GraphQL 명세

명세에는 한 언어의 능력과 특징이 기술되어 있다.

GraphQL 명세는 쿼리를 작성할 때 사용하는 언어의 문법을 설명함. 또한 타입 시스템 및 타입 시스템의 실행과 유효성 검사를 담당하는 엔진에 대해서도 설명한다.

[명세 전체적으로 읽어보기](http://spec.graphql.org/)
<br /><br />


### 1.1.2 GraphQL 설계 원칙

고려해야 할 지침

- **위계적**

    필드 안에 다른 필드가 중첩될 수 있으며, 쿼리가 그에 대한 반환 데이터는 형태가 서로 같음

- **제품 중심적**

    클라이언트가 요구하는 데이터와 클라이언트가 지원하는 언어 및 런타임에 맞춰 동작

- **엄격한 타입 제한**

    GraphQL 타입 시스템을 사용한다. 스키마의 데이터 포인트마다 특정 타입이 명시되며, 이를 기초로 유효성 검사를 받게 됨

- **클라이언트 맞춤 처리**

    클라이언트 쪽에서 받아서 사용할 수 있는 데이터를 제공

- **인트로스펙티브**

    GraphQL 언어를 사용해 GraphQL 서버가 사용하는 타입 시스템에 대한 쿼리 작성
<br /><br />

### 1.2 GraphQL의 탄생

2015년 페이스북은 GraphQL 초벌 명세와 graphql.js라는 레퍼런스 서버를 공개했다.
<br /><br />

### 1.3 데이터 전송의 역사

- **RPC**

    클라이언트에서 원격 컴퓨터로 요청 메시지를 보내 무언가 하도록 만듦

- **SOAP**

    XML을 사용해 메시지를 인코딩하고 HTTP를 사용해 전송

- **REST**

    `GET`, `PUT`, `POST`, `DELETE`와 같은 행동을 수행하여 진행하는 **리소스 중심의 아키텍처**에 대한 내용을 담고 있음. 리소스 네트워크는 가상 상태 머신이며 행동은 머신 내의 상태를 바꾼다

    RESTful 아키텍처에서 라우트는 정보를 나타내는 개념. 

    각각의 라우트를 통해 정보 요청 → 그에 따라 응답이 다르게 오게 된다.

    `/api/food/hot-dog`

    `/api/sport/skiing`

    REST를 사용하면 데이터 모델의 엔드포인트를 다양하게 만들 수 있고, 이전의 아키텍처보다 개발하기 쉽다. 데이터를 다루는 새로운 방법을 제시해 주면서도 데이터 응답형식을 자유롭게 만들 수 있는 가능성을 열어준다. 초반에는 XML과 함께 사용됐다.
<br /><br />

### 1.4 REST의 단점

- **오버페칭**

    필요하지 않은 데이터를 너무 많이 온 경우, 클라이언트가 필요한 데이터 포인트는 세 개 뿐인데, 키가 16개나 되는 객체를 받아와서 네트워크로 전송이 되어버렸다.

    ```graphql
    # query
    query {
      person(personID: 5){
        name
        height
        mass
      }
    }

    # response
    {
      "data": {
        "person": {
          "name": "Leia Organa",
          "height": 150,
          "mass": 49
        }
      }
    }
    ```

    GraphQL은 요청한 데이터만 들어있음. 요청 안에 필요한 데이터 형태를 써 두었기 때문에 그 형태 그대로 응답을 받았다. 

    **불필요한 데이터를 가져오지 않았으므로 응답속도 역시 빨라질 여지가 있다!**

- **언더페칭**

    데이터를 요청하고나서 추가 데이터를 또 요청해야한 상황일 때

    각각의 HTTP 요청이 클라이언트 리소스를 사용하는 와중에 데이터는 과도하게 가져온다. 이 때문에 사용자 체감 속도가 느려지고, 만약 네트워크나 기기의 속도가 느리다면 콘텐츠를 아예 못 볼 가능성도 있다.

    **GraphQL을 사용하면 쿼리를 중첩으로 정의해, 페치 한 번에 필요한 모든 데이터를 요청하여 언데페칭 문제를 해결할 수 있다!**
<br /><br />

### 1.4.3 REST 엔드포인트 관리

REST API에 대한 불만 중 하나는 **유연성이 부족하다**는 점 → 클라이언트에 변경 사항이 생기면 엔드포인트를 새로 만들어야한다.
<br /><br />

### 1.5.1 GraphQL 클라이언트

GraphQL 클라이언트의 목적은 개발자가 빠르게 작업할 수 있는 환경을 만들어주고 애플리케이션의 성능과 효율성을 끌어올리는 것

- [Relay](https://relay.dev/)

    페이스북에서 만든 클라이언트. React, React Native와 함께 사용가능

- [아폴로 클라이언트](https://www.apollographql.com/)

    모든 주요 프론트엔드 개발 플랫폼에서 사용가능, 프레임워크에 종속되어 있지 않음

    GraphQL API 성능 모니터링 툴 제공
